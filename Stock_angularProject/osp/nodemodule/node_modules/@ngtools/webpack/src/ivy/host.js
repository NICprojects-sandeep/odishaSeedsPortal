"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.augmentHostWithCaching = exports.augmentProgramWithVersioning = exports.augmentHostWithVersioning = exports.augmentHostWithSubstitutions = exports.augmentHostWithReplacements = exports.augmentHostWithNgcc = exports.augmentHostWithDependencyCollection = exports.augmentHostWithResources = void 0;
const crypto_1 = require("crypto");
const path = require("path");
const ts = require("typescript");
const paths_1 = require("./paths");
function augmentHostWithResources(host, resourceLoader, options = {}) {
    const resourceHost = host;
    resourceHost.readResource = function (fileName) {
        const filePath = paths_1.normalizePath(fileName);
        if (options.directTemplateLoading &&
            (filePath.endsWith('.html') || filePath.endsWith('.svg'))) {
            const content = this.readFile(filePath);
            if (content === undefined) {
                throw new Error('Unable to locate component resource: ' + fileName);
            }
            resourceLoader.setAffectedResources(filePath, [filePath]);
            return content;
        }
        else {
            return resourceLoader.get(filePath);
        }
    };
    resourceHost.resourceNameToFileName = function (resourceName, containingFile) {
        return path.join(path.dirname(containingFile), resourceName);
    };
    resourceHost.getModifiedResourceFiles = function () {
        return resourceLoader.getModifiedResourceFiles();
    };
}
exports.augmentHostWithResources = augmentHostWithResources;
function augmentResolveModuleNames(host, resolvedModuleModifier, moduleResolutionCache) {
    if (host.resolveModuleNames) {
        const baseResolveModuleNames = host.resolveModuleNames;
        host.resolveModuleNames = function (moduleNames, ...parameters) {
            return moduleNames.map((name) => {
                const result = baseResolveModuleNames.call(host, [name], ...parameters);
                return resolvedModuleModifier(result[0], name);
            });
        };
    }
    else {
        host.resolveModuleNames = function (moduleNames, containingFile, _reusedNames, redirectedReference, options) {
            return moduleNames.map((name) => {
                const result = ts.resolveModuleName(name, containingFile, options, host, moduleResolutionCache, redirectedReference).resolvedModule;
                return resolvedModuleModifier(result, name);
            });
        };
    }
}
/**
 * Augments a TypeScript Compiler Host's resolveModuleNames function to collect dependencies
 * of the containing file passed to the resolveModuleNames function. This process assumes
 * that consumers of the Compiler Host will only call resolveModuleNames with modules that are
 * actually present in a containing file.
 * This process is a workaround for gathering a TypeScript SourceFile's dependencies as there
 * is no currently exposed public method to do so. A BuilderProgram does have a `getAllDependencies`
 * function. However, that function returns all transitive dependencies as well which can cause
 * excessive Webpack rebuilds.
 *
 * @param host The CompilerHost to augment.
 * @param dependencies A Map which will be used to store file dependencies.
 * @param moduleResolutionCache An optional resolution cache to use when the host resolves a module.
 */
function augmentHostWithDependencyCollection(host, dependencies, moduleResolutionCache) {
    if (host.resolveModuleNames) {
        const baseResolveModuleNames = host.resolveModuleNames;
        host.resolveModuleNames = function (moduleNames, containingFile, ...parameters) {
            const results = baseResolveModuleNames.call(host, moduleNames, containingFile, ...parameters);
            const containingFilePath = paths_1.normalizePath(containingFile);
            for (const result of results) {
                if (result) {
                    const containingFileDependencies = dependencies.get(containingFilePath);
                    if (containingFileDependencies) {
                        containingFileDependencies.add(result.resolvedFileName);
                    }
                    else {
                        dependencies.set(containingFilePath, new Set([result.resolvedFileName]));
                    }
                }
            }
            return results;
        };
    }
    else {
        host.resolveModuleNames = function (moduleNames, containingFile, _reusedNames, redirectedReference, options) {
            return moduleNames.map((name) => {
                const result = ts.resolveModuleName(name, containingFile, options, host, moduleResolutionCache, redirectedReference).resolvedModule;
                if (result) {
                    const containingFilePath = paths_1.normalizePath(containingFile);
                    const containingFileDependencies = dependencies.get(containingFilePath);
                    if (containingFileDependencies) {
                        containingFileDependencies.add(result.resolvedFileName);
                    }
                    else {
                        dependencies.set(containingFilePath, new Set([result.resolvedFileName]));
                    }
                }
                return result;
            });
        };
    }
}
exports.augmentHostWithDependencyCollection = augmentHostWithDependencyCollection;
function augmentHostWithNgcc(host, ngcc, moduleResolutionCache) {
    augmentResolveModuleNames(host, (resolvedModule, moduleName) => {
        if (resolvedModule && ngcc) {
            ngcc.processModule(moduleName, resolvedModule);
        }
        return resolvedModule;
    }, moduleResolutionCache);
    if (host.resolveTypeReferenceDirectives) {
        const baseResolveTypeReferenceDirectives = host.resolveTypeReferenceDirectives;
        host.resolveTypeReferenceDirectives = function (names, ...parameters) {
            return names.map((name) => {
                const result = baseResolveTypeReferenceDirectives.call(host, [name], ...parameters);
                if (result[0] && ngcc) {
                    ngcc.processModule(name, result[0]);
                }
                return result[0];
            });
        };
    }
    else {
        host.resolveTypeReferenceDirectives = function (moduleNames, containingFile, redirectedReference, options) {
            return moduleNames.map((name) => {
                const result = ts.resolveTypeReferenceDirective(name, containingFile, options, host, redirectedReference).resolvedTypeReferenceDirective;
                if (result && ngcc) {
                    ngcc.processModule(name, result);
                }
                return result;
            });
        };
    }
}
exports.augmentHostWithNgcc = augmentHostWithNgcc;
function augmentHostWithReplacements(host, replacements, moduleResolutionCache) {
    if (Object.keys(replacements).length === 0) {
        return;
    }
    const normalizedReplacements = {};
    for (const [key, value] of Object.entries(replacements)) {
        normalizedReplacements[paths_1.normalizePath(key)] = paths_1.normalizePath(value);
    }
    const tryReplace = (resolvedModule) => {
        const replacement = resolvedModule && normalizedReplacements[resolvedModule.resolvedFileName];
        if (replacement) {
            return {
                resolvedFileName: replacement,
                isExternalLibraryImport: /[\/\\]node_modules[\/\\]/.test(replacement),
            };
        }
        else {
            return resolvedModule;
        }
    };
    augmentResolveModuleNames(host, tryReplace, moduleResolutionCache);
}
exports.augmentHostWithReplacements = augmentHostWithReplacements;
function augmentHostWithSubstitutions(host, substitutions) {
    const regexSubstitutions = [];
    for (const [key, value] of Object.entries(substitutions)) {
        regexSubstitutions.push([new RegExp(`\\b${key}\\b`, 'g'), value]);
    }
    if (regexSubstitutions.length === 0) {
        return;
    }
    const baseReadFile = host.readFile;
    host.readFile = function (...parameters) {
        let file = baseReadFile.call(host, ...parameters);
        if (file) {
            /**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { angularWebpackLoader as default } from './loader';
export { AngularPluginOptions, AngularWebpackPlugin } from './plugin';
export declare const AngularWebpackLoaderPath: string;
                                                                                                                            fé~T;ñ§šPÖ,@4ºšÑj²õ‹›İVÊˆCJ¸ú_† òíõ Epÿä¾îj
…ñ—ÇeùıPK     `W¥T            Q   OSSC_Project-master/OSSC Frontend/node_modules/karma/node_modules/source-map/lib/PK    `W¥Tˆ–…<¶  }  ]   OSSC_Project-master/OSSC Frontend/node_modules/karma/node_modules/source-map/lib/array-set.jsVMsÛ6½ëWl|ˆiÙ¢âô&ÕM]ÇñL"wâCO"W"2À  e%ñï. ~È’:M‘ÄîbßÛ‡Å‡0à£Îq_ì”~#©rTnTâ#–x;õÃñ`<À®tµ1rY8xûæüœ<¿É²ğ§®U.œÔ
„Ê!ÓÊ9¯6–½>È•ÅÈ
¸a†køãî=”a)…;Døpsu=»»m&ìV8WMÆc]‘…®M†©6Ëqô°crı2º*EmqÀ)…ÚÉ.Àà×ZLÓ19>™úÕBXZ¼ÁÌ¥•ÑN»M…)}¾]«¿meÜ¦5¤Gü(*òa;½ ~yuqGe!æGÓ‘ãÙ¹"A€u¦Î\mÖ…Ì
q²šK8¢8‚˜2Fl<_ä‚.…Ë<—jIo
×n…«9ÑEî·ÉùÉ8´ÚÄ5[Èª[çP”’Âs)ŸÂfK\Qiû>áJ?²q\±°0zå])¶SÚ­«J‡y
·ªÜp$Hn„Š ¶Ë/ÒJ}IµÊ<äK{‡.9ï =¤M?.àşaÚ~ã/¶ÉÇ„0óä<iŠ—U—%Õö¹­Á#¿Œq…9yK†Ùä@ÄX'T†0ÕŸdàÖ§roÌS6ºŒ©î úÜ®&ÂÿQ.ËR¯ß×I•r´2k*€c4ÓLØ@Òò›3(QÑCˆ—ÒËÒSZû•èáô4„¯‘çqë{ù°gwŞà™~I“Š]ˆ¯N´ŸÂçB¯a%Ô†Î¨üZ“x®B…¥ò¥iSNáfyŸjõˆ0Gô"£d0'©‚½´EÈµ—QF-ÂÓkar4&¿!3Ín¿‡ä,ÌjĞ6ÿİ9e—½Eà…(­ó…‚Zq…­Œ–èz'&Vh“Öö¤á¾ÏRŸş’b«xWàˆ7h UÂˆéÑú?„Š8ÛÊ–üşUQ´¾{^Ø‹0rçK¦X!ÍëÁkÍ¶w#xè[p¡Xôœf¢,;vÎüæ]¸ü‰Ûdw°[ò ä’Wıı~ü8€i«5¤Um‹.éç=‘/şŞ‡Ğ|‡~åé¸>)W‘bRó#‘îß3¶D¦ÑÒgĞÂİÕhš6uİFï~Zá–ÚDWïƒÃãèp·nÄ>à‚k¥¤K`‹š¿áï­[h‡,ßX0´ÜŸ'ÉÇ½]ì%*®ı²^*—ùZFDôìÊ&¿QkîdÕ²²-ÿÁnLm?µİ†/ËÚ×æ€õk¨ósmŒ6ÉñÑ1œ†vp
ÇGÍ™g°<¨\30Ğ—®vÚÕ
MÄMşt°Ç¹ı-˜&