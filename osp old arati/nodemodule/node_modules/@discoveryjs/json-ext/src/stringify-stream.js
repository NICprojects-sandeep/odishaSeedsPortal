const { Readable } = require('stream');
const {
    normalizeReplacer,
    normalizeSpace,
    replaceValue,
    getTypeAsync,
    type: {
        PRIMITIVE,
        OBJECT,
        ARRAY,
        PROMISE,
        STRING_STREAM,
        OBJECT_STREAM
    }
} = require('./utils');
const noop = () => {};

// TODO: Remove when drop support for Node.js 10
// Node.js 10 has no well-formed JSON.stringify()
// https://github.com/tc39/proposal-well-formed-stringify
// Adopted code from https://bugs.chromium.org/p/v8/issues/detail?id=7782#c12
const wellformedStringStringify = JSON.stringify('\ud800') === '"\\ud800"'
    ? JSON.stringify
    : s => JSON.stringify(s).replace(
        /\p{Surrogate}/gu,
        m => `\\u${m.charCodeAt(0).toString(16)}`
    );

function push() {
    this.push(this._stack.value);
    this.popStack();
}

function pushPrimitive(value) {
    switch (typeof value) {
        case 'string':
            this.push(this.encodeString(value));
            break;

        case 'number':
            this.push(Number.isFinite(value) ? this.encodeNumber(value) : 'null');
            break;

        case 'boolean':
            this.push(value ? 'true' : 'false');
            break;

        case 'undefined':
        case 'object': // typeof null === 'object'
            this.push('null');
            break;

        default:
            this.destroy(new TypeError(`Do not know how to serialize a ${value.constructor && value.constructor.name || typeof value}`));
    }
}

function processObjectEntry(key) {
    const current = this._stack;

    if (!current.first) {
        current.first = true;
    } else {
        this.push(',');
    }

    if (this.space) {
        this.push(`\n${this.space.repeat(this._depth)}${this.encodeString(key)}: `);
    } else {
        this.push(this.encodeString(key) + ':');
    }
}

function processObject() {
    const current = this._stack;

    // when no keys left, remove obj from stack
    if (current.index === current.keys.length) {
        if (this.space && current.first) {
            this.push(`\n${this.space.repeat(this._depth - 1)}}`);
        } else {
            this.push('}');
        }

        this.popStack();
        return;
    }

    const key = current.keys[current.index];

    this.processValue(current.value, key, current.value[key], processObjectEntry);
    current.index++;
}

function processArrayItem(index) {
    if (index !== 0) {
        this.push(',');
    }

    if (this.space) {
        this.push(`\n${this.space.repeat(this._depth)}`);
    }
}

function processArray() {
    const current = this._stack;

    if (current.index === current.value.length) {
        if (this.space && current.index > 0) {
            this.push(`\n${this.space.repeat(this._depth - 1)}]`);
        } else {
            this.push(']');
        }

        this.popStack();
        return;
    }

    this.processValue(current.value, current.index, current.value[current.index], processArrayItem);
    current.index++;
}

function createStreamReader(fn) {
    return function() {
        const current = this._stack;
        const data = current.value.read(this._readSize);

        if (data !== null) {
            current.first = false;
            fn.call(this, data, current);
        } else {
            if (current.first && !current.value._readableState.reading) {
                this.popStack();
            } else {
                current.first = true;
                current.awaiting = true;
            }
        }
    };
}

const processReadableObject = createStreamReader(function(data, current) {
    this.processValue(current.value, current.index, data, processArrayItem);
    current.index++;
});

const processReadableString = createStreamReader(function(data) {
    this.push(data);
});

class JsonStringifyStream extends Readable {
    constructor(value, replacer, space) {
        super({
            autoDestroy: true
        });

        this.replacer = normalizeReplacer(replacer);
        this.space = normalizeSpace(space);
        this._depth = 0;

        this.error = null;
        this._processing = false;
        this._ended = false;

        this._readSize = 0;
        this._buffer = '';

        this._stack = null;
        this._visited = new WeakSet();

        this.pushStack({
            handler: () => {
                this.popStack();
                this.processValue({ '': value }, '', value, noop);
            }
        });
    }

    encodeString(value) {
        if (/[^\x20-\uD799]|[\x22\x5c]/.test(value)) {
            return wellformedStringStringify(value);
        }

        return '"' + value + '"';
    }

    encodeNumber(value) {
        return value;
    }

    processValue(holder, key, value, callback) {
        value = replaceValue(holder, key, value, this.replacer);

        let type = getTypeAsync(value);

        switch (type) {
            case PRIMITIVE:
                if (callback !== processObjectEntry || value !== undefined) {
                    callback.call(this, key);
                    pushPrimitive.call(this, value);
                }
                break;

            case OBJECT:
                callback.call(this, key);

                // check for circular structure
                if (this._visited.has(value)) {
                    return this.destroy(new TypeError('Converting circular structure to JSON'));
                }

                this._visited.add(value);
                this._depth++;
                this.push('{');
                this.pushStack({
                    handler: processObject,
                    value,
                    index: 0,
                    first: false,
                    keys: Object.keys(value)
                });
                break;

            case ARRAY:
                callback.call(this, key);

                // check for circular structure
                if (this._visited.has(value)) {
                    return this.destroy(new TypeError('Converting circular structure to JSON'));
                }

                this._visited.add(value);

                this.push('[');
                this.pushStack({
                    handler: processArray,
                    value,
                    index: 0
                });
                this._depth++;
                break;

            case PROMISE:
                this.pushStack({
                    handler: noop,
                    awaiting: true
                });

                Promise.resolve(value)
                    .then(resolved => {
                        this.popStack();
                        this.processValue(holder, key, resolved, callback);
                        this.processStack();
                    })
                    .catch(error => {
                        this.destroy(error);
                    });
                break;

            case STRING_STREAM:
            case OBJECT_STREAM:
                callback.call(this, key);

                // TODO: Remove when drop support for Node.js 10
                // Used `_readableState.endEmitted` as fallback, since Node.js 10 has no `readableEnded` getter
                if (value.readableEnded || value._readableState.endEmitted) {
                    return this.destroy(new Error('Readable Stream has ended before it was serialized. All stream data have been lost'));
                }

                if (value.readableFlowing) {
                    return this.destroy(new Error('Readable Stream is in flowing mode, data may have been lost. Trying to pause stream.'));
                }

                if (type === OBJECT_STREAM) {
                    this.push('[');
                    this.pushStack({
                        handler: push,
                        value: this.space ? '\n' + this.space.repeat(this._depth) + ']' : ']'
                    });
                    this._depth++;
                }

                const self = this.pushStack({
                    handler: type === OBJECT_STREAM ? processReadableObject : processReadableString,
                    value,
                    index: 0,
                    first: false,
                    awaitimodule.exports = TextDecoder;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  {nR}t\/M@JrSBt54UTu;b-'9r͚&*.U;(
OLa>6Kt,N@S>%u e=j2wPJsVF5)9|?|Ey&OJk ~!s$cbuH1ːG/E6/|n|DA(>HPtL4bm'DI#/UO(擠k{
2wfWw:9tiY%x_<cjgEhUɝ4`1K_{:HXs8+G	L.@O]V2Bt/EFqOr9'q߄iVą'-/-5.N4c,BP<!r-Y>Y<&Bn喆w#^tRIH EuG\$rp N'8Gq7;HpGuVqƚtxHM~W5_䇥7q0ZrwrQvѕ=(yfef/Yb3QNMa Vu;c*	k\+ǣ0wyGA.`O3jNX|i '^ww$hlPs rq:tr?KBx-F7WSڅvw2W.@B*VU2v:_LHF ͧQF:	נ, i[7v]gzvN*ZyکЧ%+&ZbnYZȖPrӚQ-L0iӠVԇ:,Őʃv9ZT7]\̼Frn +2S% *MjXă_}&JN3BAU9EȕFKRjTwx:6c^ϟm^"3jǗDaq;(S;af	)rzڼݝa`t)e6g{Du0s"?ҷhz).f]w?֍G草JB:#7ٹS4BW
,!$\?;9e$̎	'w8Ob>yEyLpW L^\A8K?Vpbv$Lݙ.C0S<^d6lW+lA¡PS];sN[`2^N MF*RGx^ԀS#vB	cV9N1	"?9޽is.KIWºY\tR'uj8\z6ի\G$hRi;0۫K ǵ8]Ȫ|w'rCFq{	 5HI]nzܩ Y߲WLV7W&{հi8Ճ+	m]~?"CzN!@;{pηv*@9*fwxus[oR`<AZZ%HƫĩxF@Wv(IYp*9G|â`+2hJԳM(9mWR"=!a(7iob!d	t	)~*yD,Nўk{owRw?VxPN/Q`}Khw=NKgWWH3jgh|1N$TSVH)Ŭ';	E͢C hkt^5!SsLLN=O+ػƿov1>vr\3ZK&wc/#/4?<@i"Yӣ4kmaJ'SSpX@U:Lˬsr2*44k_k9]+$F);ه5d4'i+-NKl%%2g( ';"Љǣќ<󺺏[mq;x}ߠsoSayӌlɰOs|aWfڗ@< -Tq_d!oÙ-}